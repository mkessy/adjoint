---
globs: packages/domain/src/**/*.ts
description: Effect patterns for domain layer services
---

# Domain Layer Effect Patterns

## Architecture Principles

- **Pure Effect Services**: Domain services should only use Effect, Stream, and core Effect types
- **No UI Dependencies**: Domain layer must never import React, effect-rx, or web-specific modules
- **Business Logic Focus**: Contains graph operations, state management, validation, and core business rules
- **Service Pattern**: Use `Context.Tag` and `Layer` for dependency injection

## Required Patterns

### Service Definition

```typescript
export class MyService extends Context.Tag("MyService")<
  MyService,
  {
    readonly operation: Effect.Effect<Result, Error, Requirements>
    readonly stream: Stream.Stream<Data, Error, Requirements>
  }
>() {}
```

### Effect Generator Functions

Always use proper generator syntax:

```typescript
Effect.gen(function* () {
  const service = yield* MyService
  const result = yield* service.operation
  return result
})
```

### Error Handling

Use branded error types from [error.ts](mdc:packages/domain/src/error.ts):

```typescript
return (
  yield *
  Effect.fail(
    new ValidationError({
      message: "Validation failed",
      details: errorDetails
    })
  )
)
```

### Layer Creation

```typescript
export const MyServiceLive = Layer.effect(
  MyService,
  Effect.gen(function* () {
    // Service implementation
    return MyService.of({
      operation: implementOperation,
      stream: implementStream
    })
  })
)
```

### Advanced Service with Caching

```typescript
export class DataService extends Context.Tag("DataService")<
  DataService,
  {
    readonly getData: (id: string) => Effect.Effect<Data, DataError>
    readonly searchData: (query: string) => Stream.Stream<Data>
    readonly eventStream: Stream.Stream<Event>
  }
>() {
  static Live = Layer.effect(
    this,
    Effect.gen(function* () {
      const client = yield* HttpClient.HttpClient

      // Create cache with sophisticated TTL logic
      const dataCache = yield* Cache.makeWith({
        lookup: (id: string) =>
          client
            .get(`/api/data/${id}`)
            .pipe(
              Effect.flatMap(DataSchema.decodeResponse),
              Effect.orDie,
              Effect.withSpan("DataService.getData", { attributes: { id } })
            ),
        timeToLive: (exit) => {
          if (exit._tag === "Failure") return "1 minute"
          return exit.value.length > 0 ? "1 hour" : "5 minutes"
        },
        capacity: 1024
      })

      // Search with stream processing
      const searchData = (query: string) =>
        client.get("/api/search", { urlParams: { q: query } }).pipe(
          Effect.flatMap(SearchResultSchema.decodeResponse),
          Stream.fromIterableEffect,
          Stream.take(100),
          Stream.flatMap((result) => processSearchResult(result), {
            concurrency: "unbounded"
          }),
          Stream.catchCause((cause) =>
            Effect.logDebug(cause).pipe(Stream.fromEffect, Stream.drain)
          )
        )

      return {
        getData: (id: string) => Cache.get(dataCache, id),
        searchData,
        eventStream: createEventStream()
      } as const
    })
  )
}
```

### Stream Processing Patterns

```typescript
export const processDataStream = (input: Stream.Stream<Data>) =>
  input.pipe(
    Stream.filter((item) => item.isValid),
    Stream.map((item) => transformItem(item)),
    Stream.grouped(10), // Process in batches
    Stream.mapEffect((batch) => processBatch(batch), { concurrency: 5 }),
    Stream.catchAll((error) => Stream.fromEffect(Effect.logError(error)))
  )

export const paginatedStream = <T>(
  fetcher: (page: number) => Effect.Effect<T[]>
) =>
  Stream.paginateArrayEffect(1, (page) =>
    fetcher(page).pipe(
      Effect.map((items) => [
        items,
        items.length > 0 ? Option.some(page + 1) : Option.none()
      ])
    )
  )
```

## Forbidden Patterns

- ❌ No React imports (`import React`, `useEffect`, etc.)
- ❌ No effect-rx imports (`@effect-rx/rx`, `Rx.make`, etc.)
- ❌ No Promise-based APIs (use Effect instead)
- ❌ No direct state mutation (use Ref, SubscriptionRef)
- ❌ No browser-specific APIs

## File Organization

- Services in `services/` subdirectories
- Types in `types/` subdirectories
- Shared utilities in module root
- Tests co-located with implementation
