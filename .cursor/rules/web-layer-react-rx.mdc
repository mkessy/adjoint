---
globs: packages/web/src/**/*.tsx,packages/web/src/**/*.ts
description: React effect-rx patterns for UI components
---

# Web Layer React Effect-RX Patterns

## Architecture Purpose

React components using effect-rx hooks for reactive UI updates. No direct Effect usage - consume Rx objects from integration layer.

## Required Hook Patterns

### Reading Reactive Values

```typescript
import {
  useRxSuspenseSuccess,
  useRx,
  useRxValue,
  useRxRefresh
} from "@effect-rx/rx-react"

// For domain data (with suspense)
const data = useRxSuspenseSuccess(dataRx)

// For UI state (immediate read/write)
const [uiState, setUiState] = useRx(uiStateRx)

// For read-only reactive values
const todos = useRxValue(todosRx)
const optimisticTodos = useRxValue(optimisticTodosRx)

// For action state monitoring
const addTodoState = useRxValue(addTodoRx)
const isProcessing = addTodoState.waiting

// For manual refresh capability
const refreshData = useRxRefresh(dataRx)
```

### Action Functions

```typescript
import { useRxSetPromise, useRxSet } from "@effect-rx/rx-react"

// For async actions with Result handling
const performAction = useRxSetPromise(actionRx)

const handleClick = async () => {
  const result = await performAction(params)
  Result.match(result, {
    onSuccess: (value) => console.log("Success:", value),
    onFailure: (error) => console.error("Error:", error)
  })
}

// For optimistic actions (immediate UI feedback)
const addTodo = useRxSet(optimisticAddTodoRx)
const removeTodo = useRxSet(optimisticRemoveTodoRx)

const handleAddTodo = () => {
  addTodo(inputValue) // UI updates immediately
}
```

### Component Structure

```typescript
import React, { Suspense } from "react"
import { useRxSuspenseSuccess } from "@effect-rx/rx-react"

export const MyComponent: React.FC = () => {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <MyContent />
    </Suspense>
  )
}

const MyContent: React.FC = () => {
  // Reactive values from integration layer
  const data = useRxSuspenseSuccess(dataRx)
  const stats = useRxSuspenseSuccess(statsRx)

  // Local UI state only
  const [selectedId, setSelectedId] = React.useState<string | null>(null)

  return <div>{/* component JSX */}</div>
}
```

## Import Patterns

```typescript
// effect-rx React hooks
import {
  useRx,
  useRxSuspenseSuccess,
  useRxSetPromise
} from "@effect-rx/rx-react"

// Domain Rx objects (never direct Effect)
import { dataRx, actionsRx } from "../services/MyRx.js"

// Effect types for Result handling only
import { Result } from "effect"
```

## State Management Rules

### Domain State

- ✅ Use reactive values from integration layer
- ✅ Subscribe with effect-rx hooks
- ❌ Never manipulate domain state directly

### UI State

- ✅ Use React useState for component-local state
- ✅ Use Rx.state() for shared UI state
- ✅ Keep UI concerns separate from business logic

### Derived State

```typescript
// Compute derived values in render
const selectedItem = React.useMemo(
  () => items.value.find((item) => item.id === selectedId),
  [items.value, selectedId]
)
```

## Optimistic Updates

Handle immediate UI feedback with eventual consistency:

```typescript
function TodoList() {
  // Show optimistic version for immediate updates
  const optimisticTodos = useRxValue(optimisticTodosRx)
  const trueTodos = useRxValue(todosRx) // Actual server state

  // Action functions for optimistic updates
  const addTodo = useRxSet(optimisticAddTodoRx)
  const removeTodo = useRxSet(optimisticRemoveTodoRx)

  // Monitor action states
  const addTodoState = useRxValue(addTodoRx)
  const removeTodoState = useRxValue(removeTodoRx)

  return (
    <div>
      {optimisticTodos.map((todo) => (
        <div key={todo.id}>
          {todo.text}
          <button
            onClick={() => removeTodo(todo.id)}
            disabled={removeTodoState.waiting}
          >
            {removeTodoState.waiting ? "Removing..." : "Remove"}
          </button>
        </div>
      ))}
    </div>
  )
}
```

## Error Handling

Always handle Results from actions:

```typescript
const handleAction = async () => {
  const result = await performAction(data)

  Result.match(result, {
    onSuccess: (value) => {
      // Handle success
      setMessage("Operation successful")
    },
    onFailure: (error) => {
      // Handle error
      setError(error.message)
    }
  })
}
```

## Forbidden Patterns

- ❌ No direct Effect usage (`Effect.gen`, `Effect.runPromise`)
- ❌ No Stream subscriptions (use Rx objects)
- ❌ No domain service imports
- ❌ No business logic in components
- ❌ No Promise-based state management

## Service Integration

Import from service layer, not domain:

```typescript
// ✅ Correct
import { workspaceRx, workspaceActionsRx } from "../services/WorkspaceRx.js"

// ❌ Wrong - don't import domain directly
import { WorkspaceStateService } from "@adjoint/domain"
```
